# 实验报告

## 实验目的

编写一个词法分析程序，完整地实践从正规表达式到 NFA，再转化为 DFA，经过优化之后依据其编写代码的过程

## 实验过程

- 选取 Java 语言中较为基础且常用的保留字和符号构建类别码表，并写出正规表达式
- 将每个正规表达式独立构造为一个 NFA
- 合并 NFA，将其转化为 DFA 并做优化
- 根据最终结果编写代码

## 程序设计

- 读取文件中的文本，以 java.lang.String 类型传入主要的解析函数 scan()
- scan() 逐个读取字符串中的字符并做判断
  - 读取的同时记录行号和列号，以便准确定位符号串和提供报错位置
  - 符号串最后以 Token<类别码，符号串> 的格式被识别
  - 每个 Token 都被保存在各自类型的列表中
- scan() 解析完毕后获得全部结果信息的字符串，并被输出到结果文件中

## 实验详解

### 类别码表

| 类别码 | 符号串  |
| :----: | :-----: |
|   0    | import  |
|   1    | public  |
|   2    | private |
|   3    |  class  |
|   4    |   int   |
|   5    |  char   |
|   6    | String  |
|   7    |  void   |
|   8    | return  |
|   9    |   if    |
|   10   |  else   |
|   11   |   for   |
|   12   |  break  |
|   13   |  while  |
|   14   | static  |
|   15   |    +    |
|   16   |    -    |
|   17   |    *    |
|   18   |    /    |
|   19   |   +=    |
|   20   |   -=    |
|   21   |   ++    |
|   22   |   --    |
|   23   |   ==    |
|   24   |   !=    |
|   25   |    >    |
|   26   |    <    |
|   27   |   \>=   |
|   28   |   <=    |
|   29   |    =    |
|   32   |    (    |
|   33   |    )    |
|   34   |    [    |
|   35   |    ]    |
|   36   |    {    |
|   37   |    }    |
|   38   |    !    |
|   39   |    .    |
|   40   |    :    |
|   41   |    ;    |
|   42   |    '    |
|   43   |    "    |
|   44   | $Num$ |
|   45   | $Word$ |

### 正规表达式

- $Num$：$Num\rightarrow digit+$
  - $digit\rightarrow0|1|2|3|4|5|6|7|8|9​$
- $Word$：$Word\rightarrow (letter|Letter)+$
  - $letter\rightarrow a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z$
  - $Letter\rightarrow A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|p|Q|R|S|T|U|V|W|X|Y|Z​$
- 其余类别码表中符号串的正规表达式即如表中所示

### DFA

> TODO

### 测试用例

测试用例基本包含了全部的类别码，但对于一些作用相近的类别，如 [ +|-|*|/ ] [ ++|-- ] [ ==|!=|>|<|>=|<= ]，仅选取其中某一种或几种作为代表

```java
import java.util.*;

public class Test {
    private static void func() {
        int[] list;
        char c = 'A';
        String s = "@";

        for (int i = 0; i < 3; i++) {
            i += 2;
        }

        while (1) {
            if (c != 3)
                break;
            else
                return;
        }
    }
}
```

### 输出结果

```
【0, import】
【45, java】
【39, .】
【45, util】
【39, .】
【17, *】
【41, ;】
【1, public】
【3, class】
【45, Test】
【36, {】
【2, private】
【14, static】
【7, void】
【45, func】
【32, (】
【33, )】
【36, {】
【4, int】
【34, [】
【35, ]】
【45, list】
【41, ;】
【5, char】
【45, c】
【29, =】
【42, '】
【45, A】
【42, '】
【41, ;】
【6, String】
【45, s】
【29, =】
【43, "】
parse error: row 7, col 22, invalid syntax @
【43, "】
【41, ;】
【11, for】
【32, (】
【4, int】
【45, i】
【29, =】
【44, 0】
【41, ;】
【45, i】
【26, <】
【44, 3】
【41, ;】
【45, i】
【21, ++】
【33, )】
【36, {】
【45, i】
【19, +=】
【44, 2】
【41, ;】
【37, }】
【13, while】
【32, (】
【44, 1】
【33, )】
【36, {】
【9, if】
【32, (】
【45, c】
【24, !=】
【44, 3】
【33, )】
【12, break】
【41, ;】
【10, else】
【8, return】
【41, ;】
【37, }】
【37, }】
【37, }】
```

## 问题与解决

- 保留字判断问题
  - 保留字不能够像其他符号串一样判断，原因如下：
    - $Word$ 中可能包含保留字，如 important 包含 import
    - 保留字长度较长，如果采取 += 这种的硬编码方式将产生大量冗余代码
  - 解决方案
    - 将保留字存储在一个列表中，索引与保留字的类别码相对应
    - 在 $Word$ 的解析完成后，在保留字列表中查询最终获得的字符串，若查询成功，则说明 $Word​$ 是一个保留字

## 感受与思考

- 巩固了从 RE 到 NFA 到 DFA 的操作过程
- 尝试并完成了依据 DFA 编写代码的工作，对词法分析器的原理有更深入的了解
- 对于词法分析器的输入输出意义更加明确，对以后理解和编写语法分析器有很大帮助